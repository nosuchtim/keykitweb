# Runtime Library Loading for KeyKit WebAssembly

This document explains how KeyKit library files are loaded at runtime into the Emscripten virtual filesystem.

## Overview

KeyKit needs access to its library files (`.k`, `.kc`, `.kb`, `.kbm`, `.exp`, `.txt`, `.ppm` files) which are stored in the `lib/` directory. In the WebAssembly build, these files are loaded at runtime from the server and placed into a virtual filesystem that the C code can access using standard file I/O functions like `fopen()`, `fread()`, etc.

## How It Works

### 1. Library Manifest

The `lib/lib_manifest.json` file contains a JSON array listing all library files:

```json
[
  "keylib.k",
  "util1.k",
  "util2.k",
  ...
]
```

This manifest is generated by running:
```bash
cd lib
bash generate_manifest.sh
```

### 2. Runtime Loading in HTML Shell

The `src/keykit_shell.html` file contains a `loadLibraryFiles()` function that:

1. Creates virtual directories `/keykit/` and `/keykit/lib/`
2. Fetches `lib_manifest.json` to get the list of files
3. Loads files in batches of 10 for optimal performance
4. Writes each file to the virtual filesystem using `FS.writeFile()`
5. Shows progress updates during loading

### 3. Virtual Filesystem Access

Once loaded, C code can access these files using standard paths:

```c
// Open a library file
FILE *fp = fopen("/keykit/lib/keylib.k", "r");
if (fp) {
    // Read file contents
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), fp)) {
        // Process line
    }
    fclose(fp);
}
```

## File Structure

```
keykitweb/
├── lib/
│   ├── generate_manifest.sh      # Script to generate manifest
│   ├── lib_manifest.json          # Auto-generated file list
│   ├── keylib.k                   # Library files
│   ├── util1.k
│   └── ...
└── src/
    ├── keykit_shell.html          # Contains loadLibraryFiles()
    ├── build_wasm.py              # Build script with FORCE_FILESYSTEM=1
    └── mdep_wasm.c                # Can use fopen() etc.
```

## Key Features

### Batch Loading
Files are loaded in batches of 10 concurrent fetches to balance performance and browser limitations:

```javascript
const batchSize = 10;
for (let i = 0; i < libFiles.length; i += batchSize) {
    const batch = libFiles.slice(i, i + batchSize);
    await Promise.all(batch.map(async (filename) => { ... }));
}
```

### Progress Tracking
The UI shows loading progress:
- Status text: "Loading library files (45/320)..."
- Progress bar updates after each batch
- Console logging for debugging

### Error Handling
- Individual file load failures are logged but don't stop the process
- If manifest fetch fails, KeyKit continues without library files
- All errors are logged to console for debugging

## Build Configuration

The `build_wasm.py` script includes these essential flags:

```python
"-s", "FORCE_FILESYSTEM=1",     # Enable virtual filesystem
"-s", "EXPORTED_RUNTIME_METHODS=['ccall','cwrap','getValue','setValue','UTF8ToString','FS']",
```

The `FS` API is exported so JavaScript can create and manipulate files.

## Module PreRun Hook

The loading happens in the Emscripten Module's `preRun` hook:

```javascript
var Module = {
    preRun: [loadLibraryFiles],  // Called before main()
    postRun: [],
    ...
};
```

This ensures all library files are available before the C `main()` function executes.

## Testing

To verify library files are loaded:

1. Open browser DevTools Console
2. Load `keykit.html`
3. Look for messages:
   - "Loading KeyKit library files..."
   - "Found 320 library files in manifest"
   - "Loaded 10/320 files..."
   - "✓ Successfully loaded 320 library files into /keykit/lib/"
   - "Virtual filesystem contains 320 files"

4. In C code, test file access:
```c
FILE *fp = fopen("/keykit/lib/keylib.k", "r");
if (fp) {
    printf("Successfully opened keylib.k\n");
    fclose(fp);
} else {
    printf("Failed to open keylib.k\n");
}
```

## Updating the Manifest

Whenever files are added or removed from `lib/`, regenerate the manifest:

```bash
cd lib
bash generate_manifest.sh
```

Commit both the new files and the updated `lib_manifest.json`.

## Alternative: Build-Time Packaging

For faster loading, you could alternatively package files at build time using Emscripten's `--preload-file`:

```python
# In build_wasm.py
if os.path.exists("../lib"):
    flags.extend(["--preload-file", "../lib@/keykit/lib"])
```

This creates a `.data` file that loads faster but increases initial download size. The current runtime approach is more flexible for development and allows selective file loading in the future.

## Performance Notes

- **Batch size**: 10 concurrent fetches balances speed vs. browser connection limits
- **File count**: ~320 files load in approximately 2-5 seconds on localhost
- **Network**: Loading time scales with network latency for remote servers
- **Caching**: Browser automatically caches fetched files for subsequent loads

## Common Issues

### "Failed to load file.k: 404"
- File exists in `lib/` but not in manifest
- Solution: Regenerate manifest with `generate_manifest.sh`

### "FS is not defined"
- `FS` API not exported from Emscripten
- Solution: Verify `build_wasm.py` exports `FS` in `EXPORTED_RUNTIME_METHODS`

### Files load but can't be opened in C
- Wrong path (use `/keykit/lib/filename.k` not relative paths)
- File loaded as binary array but has encoding issues
- Solution: Check console for errors, verify file content in `FS.readdir()`

## Future Enhancements

Possible improvements:
1. **Lazy loading**: Load files only when `fopen()` requests them
2. **Compression**: Serve files as `.gz` and decompress in browser
3. **IndexedDB persistence**: Cache loaded files across sessions
4. **Selective loading**: Load only core library files, skip optional ones
5. **Service Worker**: Pre-cache library files for offline use
